# Comparison of Linked List Types

## 1. Singly Linked List
- **Structure**: Each node has data + next pointer
- **Space Complexity**: O(n) for n nodes
- **Traversal**: Forward only (head to tail)

### Time Complexity:
- **Insert at beginning**: O(1)
- **Insert at end**: O(n) (need to traverse to end)
- **Insert at middle**: O(n) (need to traverse to position)
- **Delete at beginning**: O(1)
- **Delete at end**: O(n) (need to traverse to end)
- **Delete at middle**: O(n) (need to traverse to position)
- **Search/Traverse**: O(n)

## 2. Doubly Linked List
- **Structure**: Each node has data + next + prev pointers
- **Space Complexity**: O(n) for n nodes (extra pointer per node)
- **Traversal**: Forward and backward

### Time Complexity:
- **Insert at beginning**: O(1)
- **Insert at end**: O(1) (if tail pointer available) or O(n) (if no tail)
- **Insert at middle**: O(n) (need to traverse to position)
- **Delete at beginning**: O(1)
- **Delete at end**: O(1) (if tail pointer available) or O(n) (if no tail)
- **Delete at middle**: O(n) (need to traverse to position)
- **Search/Traverse**: O(n) (both directions)

## 3. Circular Singly Linked List
- **Structure**: Each node has data + next pointer, last node points to first
- **Space Complexity**: O(n) for n nodes
- **Traversal**: Forward only, can start from any node

### Time Complexity:
- **Insert at beginning**: O(1)
- **Insert at end**: O(1) (if tail pointer available) or O(n) (if no tail)
- **Insert at middle**: O(n) (need to traverse to position)
- **Delete at beginning**: O(n) (need to find previous node)
- **Delete at end**: O(n) (need to find previous node)
- **Delete at middle**: O(n) (need to traverse to position)
- **Search/Traverse**: O(n)

## 4. Circular Doubly Linked List
- **Structure**: Each node has data + next + prev pointers, circular connections
- **Space Complexity**: O(n) for n nodes (extra pointer per node)
- **Traversal**: Forward and backward, can start from any node

### Time Complexity:
- **Insert at beginning**: O(1)
- **Insert at end**: O(1) (if tail pointer available) or O(n) (if no tail)
- **Insert at middle**: O(n) (need to traverse to position)
- **Delete at beginning**: O(1)
- **Delete at end**: O(1) (if tail pointer available) or O(n) (if no tail)
- **Delete at middle**: O(n) (need to traverse to position)
- **Search/Traverse**: O(n) (both directions)

## Summary Comparison

| Operation                | Singly Linked | Doubly Linked | Circular Singly | Circular Doubly |
|--------------------------|---------------|---------------|-----------------|-----------------|
| **Space per Node**       | 2 fields      | 3 fields      | 2 fields        | 3 fields        |
| **Insert at Head**       | O(1)          | O(1)          | O(1)            | O(1)            |
| **Insert at Tail**       | O(n)          | O(1)*         | O(1)*           | O(1)*           |
| **Delete at Head**       | O(1)          | O(1)          | O(n)            | O(1)            |
| **Delete at Tail**       | O(n)          | O(1)*         | O(n)            | O(1)*           |
| **Insert at Middle**     | O(n)          | O(n)          | O(n)            | O(n)            |
| **Delete at Middle**     | O(n)          | O(n)          | O(n)            | O(n)            |
| **Search**               | O(n)          | O(n)          | O(n)            | O(n)            |
| **Traversal**            | Forward only  | Both ways     | Forward only    | Both ways       |
| **NULL Pointers**        | Yes           | Yes           | No              | No              |
| **Memory Efficiency**    | ⭐⭐⭐⭐⭐    | ⭐⭐⭐        | ⭐⭐⭐⭐⭐     | ⭐⭐⭐          |
| **Flexibility**          | ⭐⭐          | ⭐⭐⭐⭐      | ⭐⭐⭐         | ⭐⭐⭐⭐⭐      |

*With tail pointer available

## Key Advantages:

### Singly Linked List:
- Simple implementation
- Less memory per node
- Good for forward traversal only

### Doubly Linked List:
- Can traverse both directions
- Easier deletion (no need to track previous)
- Better for applications requiring backward navigation

### Circular Singly Linked List:
- No NULL pointers (can't get stuck at end)
- Good for round-robin scheduling
- Can start traversal from any node

### Circular Doubly Linked List:
- Best of both worlds: circular + bidirectional
- Most flexible for complex operations
- Ideal for applications like text editors, browser history

## When to Use Which:

- **Singly LL**: Simple forward-only operations, memory constrained
- **Doubly LL**: Need backward traversal, frequent deletions
- **Circular Singly**: Round-robin scenarios, no end conditions
- **Circular Doubly**: Complex navigation needs, most flexible

Array vs Linked List Comparison

1. Array
- Structure: Fixed-size contiguous memory block
- Space Complexity: O(n) for n elements
- Access: Random access via index
- Memory: Contiguous allocation

Time Complexity:
- Access by index: O(1)
- Insert at beginning: O(n) (need to shift all elements)
- Insert at end: O(1) (if space available) or O(n) (if need to resize)
- Insert at middle: O(n) (need to shift elements)
- Delete at beginning: O(n) (need to shift all elements)
- Delete at end: O(1)
- Delete at middle: O(n) (need to shift elements)
- Search (unsorted): O(n)
- Search (sorted): O(log n) with binary search

2. Linked List (any type)
- Structure: Non-contiguous nodes with pointers
- Space Complexity: O(n) for n nodes + overhead for pointers
- Access: Sequential access only
- Memory: Dynamic allocation, non-contiguous

Time Complexity:
- Access by index: O(n) (need to traverse)
- Insert at beginning: O(1)
- Insert at end: O(1) or O(n) depending on type and tail pointer
- Insert at middle: O(n) (need to traverse to position)
- Delete at beginning: O(1) or O(n) depending on type
- Delete at end: O(1) or O(n) depending on type
- Delete at middle: O(n) (need to traverse to position)
- Search: O(n) (no binary search possible)

Summary Comparison: Array vs Linked List

| Aspect | Array | Linked List |
|--------|-------|-------------|
| Memory Allocation | Contiguous | Non-contiguous |
| Random Access | O(1) | O(n) |
| Insert at Beginning | O(n) | O(1) |
| Insert at End | O(1)* | O(1)* |
| Delete at Beginning | O(n) | O(1)* |
| Delete at End | O(1) | O(1)* |
| Memory Usage | Less overhead | Pointer overhead |
| Size Flexibility | Fixed size | Dynamic size |
| Cache Performance | Better | Poorer |
| Binary Search | Possible | Not possible |

*With conditions (space available for array, tail pointer for linked list

When to Use Arrays:
- Need fast random access
- Size is known in advance
- Binary search is needed
- Cache performance is important
- Memory is constrained (less overhead)

When to Use Linked Lists:
- Frequent insertions/deletions
- Size is unknown or changes frequently
- Memory fragmentation is acceptable
- No need for random access
- Implementing other data structures (stacks, queues)